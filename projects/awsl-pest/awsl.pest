program = _{SOI~statement* ~ EOI}

statement = {
    emptyStatement  |
    importStatement ~ eos?  |
    classStatement ~ eos?  |
    extendStatement ~ eos?  |
    controlFlow ~ eos?  |
    assignStatement ~ eos?  |
    defineStatement ~ eos?  |
    annotation ~ eos?  |
    expression
}
/*====================================================================================================================*/
emptyStatement = {eos}
eos = {Semicolon}
comma_or_semi = _{Comma|Semicolon}
block_or_stmt = _{block|Set ~ statement}
/*====================================================================================================================*/
//FIXME: 修复 nested using
importStatement = {
    IMPORT ~ Dot* ~ use_alias
  | IMPORT ~ Dot* ~ use_module_select
}
use_alias = !{String ~ AS ~ SYMBOL|SYMBOL ~ (ModuleSplit ~ SYMBOL)* ~"as"~SYMBOL}
use_module_select = !{SYMBOL ~ (ModuleSplit ~ SYMBOL)* ~(ModuleSplit ~ (module_block|Star))?}
module_block = {"{"~module_tuple~ ( comma_or_semi? ~ module_tuple)* ~comma_or_semi?~"}"}
module_tuple = {use_alias|use_module_select}
ModuleSplit= _{Dot|Proportion}
//!#C678DD: IMPORT|AS
IMPORT = @{"import"}
AS     = @{"as"}
/*====================================================================================================================*/
controlFlow = _{re_control|if_statement|for_statement}
block = !{"{" ~ statement+ ~ "}"}
/*====================================================================================================================*/
if_statement = {IF ~ condition ~ block ~ ELSE ~ block}
if_single = _{IF ~ condition ~ block}
if_nested = _{IF ~ condition ~ block ~ else_if_block+}
if_single_else = _{IF ~ condition ~ block ~ else_block}
if_nested_else = _{IF ~ condition ~ block ~ else_if_block+ ~ else_block}
else_if_block = _{ELSE_IF ~ condition ~ block}
else_block = _{ELSE ~ block}
condition  = _{"(" ~ expr ~ ")"|expr}
//!#C678DD: IF|ELSE|ELSE_IF
IF      = @{"if"}
ELSE    = @{"else"}
ELSE_IF = @{"ef"| ELSE ~ IF}
/*====================================================================================================================*/
for_statement = {FOR ~ SYMBOL ~ IN ~ expr ~ block}
for_in_loop   = {SYMBOL ~ IN ~ expr ~ block}
//!#C678DD: FOR|IN
FOR = @{"for"}
IN  = @{"in"}
/*====================================================================================================================*/
re_control = {control_word ~ expr?}
/// #C678DD
control_word = @{"return"|"break"|"yield"|"continue"}
/*====================================================================================================================*/
///#C678DD
Type = @{"type"}
/*====================================================================================================================*/
classStatement = {"class" ~ assign_pair ~ short_block?}

short_block = {"{" ~ short_statement* ~ "}"}
short_statement = {
    emptyStatement
  | "def"? ~ define_terms ~ eos?
  | "let"? ~ assign_terms ~ eos?
  | short_annotation ~ eos?
}
short_annotation = {annotation_call+~short_statement}
/*====================================================================================================================*/
extendStatement = {
    "extend" ~ SYMBOL_PATH ~ ("with"|Colon)? ~ short_block
}
/*====================================================================================================================*/
assignStatement = {"let" ~ assign_terms}
assign_terms = _{
    "(" ~ assign_name ~ ")" ~ block_or_stmt?
  | assign_name ~ block_or_stmt?
}
assign_name = _{assign_pair ~ (Comma ~ assign_pair)* ~ Comma?}
assign_pair = {SYMBOL}

/*====================================================================================================================*/
defineStatement = {"def" ~ define_terms}
define_terms = _{
    assign_pair ~ define_parameter ~ block_or_stmt?
}
define_parameter = {
    "(" ~ define_pair ~ (Comma ~ define_pair)* ~ Comma? ~ ")"
  | "(" ~ ")"
}
define_pair = {SYMBOL ~ (Set ~ expr)?}
/*====================================================================================================================*/
//!Orange:annotation_call
annotation = {annotation_call+~statement}
annotation_call = @{"@"~(list|apply|SYMBOL_PATH)}
/*====================================================================================================================*/
apply = !{
     "(" ~ apply_kv? ~ (Comma ~ apply_kv)* ~ Comma? ~")"
}
apply_kv = {SYMBOL~ Colon ~ expr|expr}



///#61AFEF
function_name = {SYMBOL}
function_module = {(SYMBOL_PATH ~ Dot)? ~ (SYMBOL ~ Dot)*}
/*====================================================================================================================*/
expression    = {expr ~ eos?}
expr          = {term ~ (Infix ~ term)*}
term          = {Prefix* ~ node ~ Suffix*}
node          = {"(" ~ expr ~ ")"|tuple|bracket_call|data}
bracket_call  =${data ~ ((!NEWLINE ~ WHITESPACE)* ~ (slice|apply))+}
bracket_apply = {SYMBOL_PATH ~ dict}
dot_call      = {term ~ Dot ~ (Integer|SYMBOL_PATH) }
/*====================================================================================================================*/
template = {EmptyTemplate|Fragment|OpenClose|SelfClose}
EmptyTemplate = {"<|>"}
Fragment  = {"<>" ~ text_mode ~ "</>" }
OpenClose = {"<" ~ PUSH(SYMBOL_PATH) ~ ">" ~ text_mode+ ~ "</" ~ POP ~ ">" }
SelfClose = {"<" ~ PUSH(SYMBOL_PATH) ~ text_mode+ ~ POP ~ "/>" }
text_mode = ${
    "{" ~ statement* ~ "}"|template+|(HTMLEscape|text_char)+
}
text_char = @{
    (!("{"|"}"|"<"|">") ~ ANY)|
    "{{"| "}}" |
    "<<" | ">>"
}
HTMLEscape = @{
    "&" ~ ASCII_ALPHA_LOWER ~ ";" |
    "&#" ~ Integer ~";"
}
/*====================================================================================================================*/
data        = {template|dict|list|Boolean|Byte|Number|String|SYMBOL_PATH}

tuple       = {"(" ~ ")"|"(" ~ expr ~ Comma ~ ")"|"(" ~ expr ~ (Comma ~ expr)* ~ Comma? ~ ")"}

dict        = {"{" ~ "}"|"{" ~ pair ~ (Comma ~ pair)* ~ Comma? ~ "}"}
pair        =!{key_valid ~ Colon ~ expr}
key_valid   =!{Integer | SYMBOL | String}

list        =!{"[" ~ "]"|"[" ~ expr ~ (Comma ~ expr)* ~ Comma? ~ "]"}
slice       =!{"[" ~ index ~ (Comma ~ index)* ~ Comma? ~ "]"}
index       = {index_step|index_range|expr}
index_range =!{expr? ~ Colon ~ expr?}
index_step  =!{expr? ~ Colon ~ expr? ~ Colon ~ expr?}
/*====================================================================================================================*/
///#D19A66
Boolean = @{"true"|"false"}
/*====================================================================================================================*/
///#D19A66
Byte     = ${Byte_BIN|Byte_OCT|Byte_HEX}
Byte_BIN = ${"0" ~ ("b"|"B") ~ (Underline? ~ ASCII_BIN_DIGIT)+}
Byte_OCT = ${"0" ~ ("o"|"O") ~ (Underline? ~ ASCII_OCT_DIGIT)+}
Byte_HEX = ${"0" ~ ("x"|"X") ~ (Underline? ~ ASCII_HEX_DIGIT)+}
/*====================================================================================================================*/
//!#D19A66: Integer|Decimal|DecimalBad
Number     =${Complex|Decimal|Integer}
Decimal    =${Integer ~ Dot ~ ASCII_DIGIT+}
DecimalBad =${Integer ~ Dot|Dot ~ ASCII_DIGIT+}
Integer    =@{"0"|ASCII_NONZERO_DIGIT ~ (Underline? ~ ASCII_DIGIT)*}
Complex    = {(Decimal|Integer) ~ SYMBOL}
/*====================================================================================================================*/
//!#3C963C: String
//!#98C379: StringText|StringLiteralText
String            = ${SYMBOL? ~ (StringNormal|StringLiteral|StringEmpty)}
StringLiteral     = {StringStart ~ StringLiteralText ~ StringEnd}
StringNormal      = {Quotation ~ StringText ~ Quotation}
StringEmpty       = {Quotation{2}|Apostrophe{2}}
StringLiteralText = {(!(Apostrophe ~ PEEK) ~ ANY)*}
StringText        = {(Solidus~(Solidus|Quotation)|!Quotation ~ ANY)*}
StringStart       = @{Apostrophe{1}~PUSH(Apostrophe*)}
StringEnd         = @{POP ~ Apostrophe{1}}
/*====================================================================================================================*/
// NEWLINE = @{"\r"~"\n"|"\r"|"\n"}
WHITESPACE = {NEWLINE|WHITE_SPACE}
//!#7F848E: MultiLineComment
COMMENT = {MultiLineComment|LineCommentSimple}
///Gray
LineCommentSimple = ${ "//" ~ (!NEWLINE ~ ANY)*}
MultiLineComment = ${ "/*" ~ (MultiLineComment | !"*/" ~ ANY)* ~ "*/"}
/*====================================================================================================================*/
///#61AFEF
SYMBOL_PATH = ${SYMBOL ~ (Proportion ~ SYMBOL)*}
SYMBOL = @{
    XID_START ~  XID_CONTINUE*
  | Underline ~ XID_CONTINUE+
}
/*====================================================================================================================*/
//!Orange: Modifier
// Modifier = !{(!(SYMBOL~(Set|Colon|Semicolon|"{"|"}"|"("|")"|"<"|">")) ~SYMBOL)}
//!#56B6C2: Prefix|Infix|Postfix
Prefix = @{
    (Bang|Plus|Minus|Star)
}
Suffix = @{
   (Bang | Question)
}
Infix = _{
    Set
  | (Plus|Minus)
  | Power
  | Dot
}

///#56B6C2
Set = @{"="}

Or = @{"|"}
LazyOr = @{"||"}


Star =@{"*"}
Slash =@{"/"}
Solidus = @{"\\"}

Proportion = @{"::"|"∷"}//U+2237
Dot = @{"."}
Comma = @{","}
Semicolon = @{";"} //U+FF1B
Colon = @{":"|"："} //U+FF1A
///#56B6C2
Question=@{"?"}
Underline = @{"_"}



Load =@{"<<<"|"⋘"} //U+22D8
Save =@{">>>"|"⋙"} //U+22D9
LeftShift =@{"<<"|"≪"} //U+226A
RightShift =@{">>"|"≫"} //U+226B
LessEqual =@{"<="}
GraterEqual =@{">="}



Equivalent =@{"==="}
NotEquivalent =@{"=!="}
Equal =@{"=="}
NotEqual =@{"!="|"≠"} //U+2260







Plus =@{"+"}
Minus =@{"-"}

Power = @{"^"}
Surd = @{"√"} //U+221A


Increase =@{"++"}
Decrease =@{"--"}


To =@{"->"}


Elvis =@{":?"}


Quote =@{"`"}
Acute =@{"´"} // U+00B4
Apostrophe = @{"'"}
Quotation = @{"\""}


LogicOr =@{"||"|"∧"} //U+2227
LogicAnd =@{"&&"|"∨"} //U+2228
LogicNot =@{"¬"} //U+00AC

Ellipsis =@{"..."|"…"} // U+2026

Concat =@{"~~"}
Destruct =@{"~="}

Bang =@{"!"}

Sharp =@{"#"}
